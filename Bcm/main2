[CmdletBinding(SupportsShouldProcess = $true)]
param(
  [Parameter(Mandatory)]
  [ValidateScript({ Test-Path $_ })]
  [string] $ConfigPath,

  [Parameter(Mandatory)]
  [ValidateSet('Failover','Failback')]
  [string] $Mode
)

# --- Load and validate config ---
try {
  $cfg = (Get-Content -Path $ConfigPath -Raw -ErrorAction Stop) | ConvertFrom-Json -ErrorAction Stop
} catch {
  throw "Failed to read/parse config '$ConfigPath': $($_.Exception.Message)"
}

if (-not $cfg.Targets -or $cfg.Targets.Count -eq 0) { throw "Config must contain a non-empty 'Targets' array." }
if (-not $cfg.$Mode -or -not $cfg.$Mode.Host)       { throw "Config missing '$Mode.Host'." }
if (-not $cfg.TnsEntryNames -or $cfg.TnsEntryNames.Count -eq 0) {
  throw "Config must include 'TnsEntryNames' with at least one entry name."
}

$newHost   = [string]  $cfg.$Mode.Host
$onlyNames = [string[]]$cfg.TnsEntryNames

# Allow either BasePath (single) or BasePaths (array)
$targets = foreach ($t in $cfg.Targets) {
  if (-not $t.Computer) { throw "Each target must have 'Computer'." }

  $paths = @()
  if ($t.PSObject.Properties.Name -contains 'BasePaths' -and $t.BasePaths) { $paths += @($t.BasePaths) }
  if ($t.PSObject.Properties.Name -contains 'BasePath'  -and $t.BasePath)  { $paths += $t.BasePath }

  if ($paths.Count -eq 0) { throw "Target '$($t.Computer)' must have 'BasePath' or 'BasePaths'." }

  [pscustomobject]@{ Computer = [string]$t.Computer; BasePaths = [string[]]$paths }
}

# Honor -WhatIf by scanning and reporting, but skipping writes
$DoWhatIf = ($PSBoundParameters.ContainsKey('WhatIf') -or ($WhatIfPreference -eq $true))
if ($DoWhatIf) { Write-Verbose "WhatIf: will scan and report, but will not write files on remote hosts." }

# --- Remote code that runs on each target machine ---
$remoteBlock = {
  param(
    [string[]] $BasePaths,
    [string]   $NewHost,
    [string[]] $EntryNames,
    [bool]     $DoWhatIf
  )

  function New-BackupFile {
    param([string]$Path)
    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'
    $backup = "{0}.{1}.bak" -f $Path, $ts
    Copy-Item -LiteralPath $Path -Destination $backup -Force
    return $backup
  }

  # Preserve original encoding (incl. BOM)
  function Get-ContentWithEncoding {
    param([string]$Path)
    $fs = [System.IO.File]::Open($Path, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
    try {
      $sr = New-Object System.IO.StreamReader($fs, [System.Text.Encoding]::UTF8, $true)
      $text = $sr.ReadToEnd()
      $enc  = $sr.CurrentEncoding
    } finally { $sr.Close(); $fs.Close() }
    [pscustomobject]@{ Text=$text; Encoding=$enc }
  }
  function Set-ContentPreserveEncoding {
    param([string]$Path, [string]$Text, [System.Text.Encoding]$Encoding)
    $fs = [System.IO.File]::Open($Path, [System.IO.FileMode]::Create, [System.IO.FileAccess]::Write, [System.IO.FileShare]::None)
    try { $sw = New-Object System.IO.StreamWriter($fs, $Encoding); $sw.Write($Text) } finally { $sw.Close(); $fs.Close() }
  }

  # Regex to change HOST= (case-insensitive, tolerant spacing)
  $rxHost = [regex]'(?im)(\bHOST\s*=\s*)([^)\s]+)'

  function Replace-HostInEntryBlocks {
    param([string]$Content, [string[]]$EntryNames, [regex]$RxHost, [string]$NewHost)

    $updated = $Content
    foreach ($name in $EntryNames) {
      $escaped = [regex]::Escape($name)
      # Balanced-paren match for a TNS entry block:  ^<name> = ( ...balanced... )
      $pattern = "(?ims)^\s*$escaped\s*=\s*\((?>[^()]+|\((?<o>)|\)(?<-o>))*(?(o)(?!))\)"
      $rxBlock = [regex]::new($pattern)
      $updated = $rxBlock.Replace($updated, {
        param($m)
        $block = $m.Value
        $RxHost.Replace($block, "`$1$NewHost")
      })
    }
    return $updated
  }

  $allResults = @()

  foreach ($base in $BasePaths) {
    if (-not (Test-Path -LiteralPath $base)) {
      $allResults += [pscustomobject]@{ BasePath=$base; File=$null; Changed=$false; Backup=$null; Note="BasePath not found" }
      continue
    }

    $files = Get-ChildItem -LiteralPath $base -Recurse -Filter 'tnsnames.ora' -File -ErrorAction SilentlyContinue
    if (-not $files) {
      $allResults += [pscustomobject]@{ BasePath=$base; File=$null; Changed=$false; Backup=$null; Note="No tnsnames.ora files" }
      continue
    }

    foreach ($f in $files) {
      $data = Get-ContentWithEncoding -Path $f.FullName
      $text = $data.Text
      $orig = $text

      # Only touch the specified entries from JSON
      $text = Replace-HostInEntryBlocks -Content $text -EntryNames $EntryNames -RxHost $rxHost -NewHost $NewHost

      $changed = -not [string]::Equals($orig, $text, [System.StringComparison]::Ordinal)

      $backup = $null
      if ($changed -and -not $DoWhatIf) {
        $backup = New-BackupFile -Path $f.FullName
        Set-ContentPreserveEncoding -Path $f.FullName -Text $text -Encoding $data.Encoding
      }

      $allResults += [pscustomobject]@{
        BasePath=$base; File=$f.FullName; Changed=$changed; Backup=$backup; Note=$null
      }
    }
  }

  return $allResults
}

# --- Execute against each target ---
foreach ($t in $targets) {
  $cn = $t.Computer
  Write-Host ">>> $cn" -ForegroundColor Cyan
  try {
    $s = New-PSSession -ComputerName $cn -ErrorAction Stop
    try {
      # Not gating with ShouldProcess so -WhatIf still scans
      $res = Invoke-Command -Session $s -ScriptBlock $remoteBlock -ArgumentList @(
        $t.BasePaths, $newHost, $onlyNames, [bool]$DoWhatIf
      )

      # Summaries by BasePath
      $groups = $res | Group-Object BasePath
      foreach ($g in $groups) {
        $scanned = ($g.Group | Where-Object File).Count
        $changed = ($g.Group | Where-Object Changed).Count
        if ($DoWhatIf) {
          Write-Host ("  BasePath: {0} | WhatIf: files scanned: {1}, would change: {2}" -f $g.Name, $scanned, $changed)
        } else {
          Write-Host ("  BasePath: {0} | files scanned: {1}, changed: {2}" -f $g.Name, $scanned, $changed)
        }
        foreach ($r in $g.Group) {
          if ($r.File) {
            if ($r.Changed) {
              if ($DoWhatIf) {
                Write-Host "    WOULD UPDATE: $($r.File)"
              } else {
                Write-Host "    UPDATED: $($r.File)"
                if ($r.Backup) { Write-Host "      Backup: $($r.Backup)" }
              }
            } else {
              Write-Host "    No change: $($r.File)"
            }
          } elseif ($r.Note) {
            Write-Host "    Note: $($r.Note)"
          }
        }
      }
    } finally {
      Remove-PSSession -Session $s
    }
  } catch {
    Write-Warning "  $cn : $($_.Exception.Message)"
  }
}
