param(
    [string]$settingsFile,
    [switch]$DryRun,
    [string]$Tag = "Default",
    [int]$MaxConcurrent = 40,
    [int]$WaitTimeoutSec = 600,
    [int]$KillHungAfterSec = 3600,
    [string[]]$ExcludeExtensions = @('.bat', '.exe')  # add more like '.cmd', '.dll'
)

Write-Host "[Start] Cleanup Started $((Get-Date).ToString('yyyy-MM-dd HH:mm:ss'))"

$timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$tempDir = "$env:TEMP\cleanup_jobs_${timestamp}_$Tag"
$null = New-Item -Path $tempDir -ItemType Directory -Force
$logDir = "$tempDir\logs"
$null = New-Item -Path $logDir -ItemType Directory -Force

if (-not (Test-Path $settingsFile)) {
    Write-Error "Settings file $settingsFile not found."
    exit 1
}

try {
    $settings = Get-Content -Raw -Path $settingsFile | ConvertFrom-Json
} catch {
    Write-Error "Failed to parse JSON from $settingsFile"
    exit 1
}

$scriptStartTime = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
$allJobs = @()
$index = 0

foreach ($item in $settings) {
    $allJobs += [pscustomobject]@{
        path       = $item.path
        daystokeep = [int]$item.daystokeep
        reportPath = "$tempDir\job_$index.json"
        logPath    = "$logDir\job_$index.log"
    }
    $index++
}

# --- ScriptBlock ---
$jobScript = {
    param ($path, $keepDays, $dryRun, $reportPath, $logPath, $excludeExtensions)

    function Rename-OldItems {
        param ($path, $cutoff, $markDate, $dryRun, $logPath, $entry, $excludeExtensions)

        $markPrefix = "DELETE_BY_" + $markDate.ToString("yyyyMMdd") + "__"

        # Files: fast in-memory filtering using .Where(), including extension exclude
        $files = Get-ChildItem -Path $path -File -Force -ErrorAction SilentlyContinue
        $oldFiles = $files.Where({
            $_.LastWriteTime -lt $cutoff -and
            $_.Name -notmatch '^DELETE_BY_\d{8}__' -and
            ($excludeExtensions -notcontains $_.Extension)
        }, 'Default')

        foreach ($file in $oldFiles) {
            $newName = Join-Path $file.DirectoryName ($markPrefix + $file.Name)
            if ($dryRun) {
                $entry.renamedFileCount++
                Add-Content $logPath "Would rename file: $($file.FullName) -> $newName"
            } else {
                try {
                    Rename-Item -Path $file.FullName -NewName $newName -Force
                    $entry.renamedFileCount++
                    Add-Content $logPath "Renamed file: $($file.Name) -> $newName"
                } catch {
                    Add-Content $logPath "Failed to rename file: $($file.FullName)"
                }
            }
        }

        # Folders: fast .Where(), prevent double-marking
        $dirs = Get-ChildItem -Path $path -Directory -Force -ErrorAction SilentlyContinue
        $oldDirs = $dirs.Where({
            $_.LastWriteTime -lt $cutoff -and
            $_.Name -notmatch '^DELETE_BY_\d{8}__'
        }, 'Default')

        foreach ($dir in $oldDirs) {
            $newName = Join-Path $dir.Parent.FullName ($markPrefix + $dir.Name)
            if ($dryRun) {
                $entry.renamedFolderCount++
                Add-Content $logPath "Would rename folder: $($dir.FullName) -> $newName"
            } else {
                try {
                    Rename-Item -Path $dir.FullName -NewName $newName -Force
                    $entry.renamedFolderCount++
                    Add-Content $logPath "Renamed folder: $($dir.Name) -> $newName"
                } catch {
                    Add-Content $logPath "Failed to rename folder: $($dir.FullName)"
                }
            }
        }
    }

    function Cleanup-MarkedItems {
        param ($path, $now, $dryRun, $logPath, $entry)

        $allItems = Get-ChildItem -Path $path -Force -ErrorAction SilentlyContinue
        foreach ($item in $allItems) {
            if ($item.Name -match '^DELETE_BY_(\d{8})__') {
                $deleteBy = [datetime]::ParseExact($matches[1], 'yyyyMMdd', $null)
                if ($deleteBy -lt $now) {
                    if ($dryRun) {
                        Add-Content $logPath "Would delete: $($item.FullName)"
                        if ($item.PSIsContainer) { $entry.deletedFolderCount++ } else { $entry.deletedFileCount++ }
                    } else {
                        try {
                            if ($item.PSIsContainer) {
                                [System.IO.Directory]::Delete($item.FullName, $true)
                                $entry.deletedFolderCount++
                            } else {
                                [System.IO.File]::Delete($item.FullName)
                                $entry.deletedFileCount++
                            }
                            Add-Content $logPath "Deleted: $($item.FullName)"
                        } catch {
                            $entry.skippedDeletions++
                            Add-Content $logPath "Failed to delete: $($item.FullName)"
                        }
                    }
                }
            }
        }
    }

    $now = Get-Date
    $cutoff = $now.AddDays(-$keepDays)
    $markDate = $now.AddDays(10)

    $entry = [ordered]@{
        path = $path
        daystokeep = $keepDays
        cutoffDate = $cutoff.ToString("yyyy-MM-dd")
        markDate   = $markDate.ToString("yyyy-MM-dd")
        renamedFileCount   = 0
        renamedFolderCount = 0
        deletedFileCount   = 0
        deletedFolderCount = 0
        skippedDeletions   = 0
        note = $null
    }

    Add-Content $logPath "[$(Get-Date -Format HH:mm:ss)] Start: $path"

    if (-not (Test-Path $path)) {
        $entry.note = "Path does not exist"
        Add-Content $logPath "Path does not exist"
    } else {
        Rename-OldItems -path $path -cutoff $cutoff -markDate $markDate `
            -dryRun $dryRun -logPath $logPath -entry $entry -excludeExtensions $excludeExtensions
        Cleanup-MarkedItems -path $path -now $now -dryRun $dryRun -logPath $logPath -entry $entry
    }

    Add-Content $logPath "[$(Get-Date -Format HH:mm:ss)] Done: $path"
    $entry | ConvertTo-Json -Depth 4 | Set-Content -Path $reportPath -Encoding UTF8
}

# --- Throttled job execution ---
$runningJobs = @()
$jobIndex = 0

foreach ($jobData in $allJobs) {
    Write-Host "[Start] $((Get-Date).ToString('yyyy-MM-dd HH:mm:ss')) Job $jobIndex - $($jobData.path)"
    $job = Start-Job -ScriptBlock $jobScript `
        -ArgumentList $jobData.path, $jobData.daystokeep, $DryRun.IsPresent, $jobData.reportPath, $jobData.logPath, $ExcludeExtensions
    $runningJobs += $job
    $jobIndex++

    if ($runningJobs.Count -ge $MaxConcurrent) {
        Write-Host "[Throttle] $((Get-Date).ToString('yyyy-MM-dd HH:mm:ss')) Max $MaxConcurrent jobs reached. Waiting..."
        $done = Wait-Job -Job $runningJobs -Any -Timeout $WaitTimeoutSec
        if ($null -ne $done) {
            $ids = @($done | Select-Object -ExpandProperty Id)
            Receive-Job -Job $done -ErrorAction SilentlyContinue | Out-Null
            Remove-Job -Job $done -ErrorAction SilentlyContinue
            $runningJobs = $runningJobs | Where-Object { $ids -notcontains $_.Id }
        }
    }
}

# Final drain
while ($runningJobs.Count -gt 0) {
    Write-Host "[Throttle] $((Get-Date).ToString('yyyy-MM-dd HH:mm:ss')) Draining final batch... ($($runningJobs.Count) running)"
    $done = Wait-Job -Job $runningJobs -Any -Timeout $WaitTimeoutSec
    if ($null -ne $done) {
        $ids = @($done | Select-Object -ExpandProperty Id)
        Receive-Job -Job $done -ErrorAction SilentlyContinue | Out-Null
        Remove-Job -Job $done -ErrorAction SilentlyContinue
        $runningJobs = $runningJobs | Where-Object { $ids -notcontains $_.Id }
    }
}

# Safety cleanup
$left = Get-Job -ErrorAction SilentlyContinue
if ($left) {
    Receive-Job -Job $left -ErrorAction SilentlyContinue | Out-Null
    Remove-Job -Job $left -Force -ErrorAction SilentlyContinue
}

# Merge results
$summary = [ordered]@{
    startedAt = $scriptStartTime
    endedAt   = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    dryRun    = $DryRun.IsPresent
    entries   = @()
}

for ($i = 0; $i -lt $allJobs.Count; $i++) {
    $jobFile = "$tempDir\job_$i.json"
    if (Test-Path $jobFile) {
        $data = Get-Content -Raw -Path $jobFile | ConvertFrom-Json
        $summary.entries += $data
    }
}

$finalReport = "cleanup_summary_${timestamp}_$Tag.json"
$summary | ConvertTo-Json -Depth 4 | Set-Content -Path $finalReport -Encoding UTF8

Write-Host "`nCleanup complete. Summary saved to: $finalReport"
Write-Host "Logs saved to: $logDir"
