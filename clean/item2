param (
    [string]$settingsFile,
    [switch]$DryRun
)

# Setup
$timestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$tempDir = "$env:TEMP\cleanup_jobs_$timestamp"
$null = New-Item -Path $tempDir -ItemType Directory -Force

if (-not (Test-Path $settingsFile)) {
    Write-Error "Settings file '$settingsFile' not found."
    exit 1
}

try {
    $settings = Get-Content -Raw -Path $settingsFile | ConvertFrom-Json
} catch {
    Write-Error "Failed to parse JSON from $settingsFile: $_"
    exit 1
}

# Launch a job per path
$jobs = @()
$index = 0
foreach ($item in $settings) {
    $jobSettings = @{
        path = $item.path
        daystokeep = [int]$item.daystokeep
        dryRun = $DryRun.IsPresent
        outputPath = "$tempDir\job_$index.json"
    }

    $job = Start-Job -ScriptBlock {
        param ($path, $daystokeep, $dryRun, $outputPath)

        $now = Get-Date
        $cutoff = $now.AddDays(-$daystokeep)

        $entry = [ordered]@{
            path = $path
            daystokeep = $daystokeep
            cutoffDate = $cutoff.ToString("yyyy-MM-dd HH:mm:ss")
            deletedFileCount = 0
            deletedFolderCount = 0
            skippedFolderCount = 0
            note = $null
        }

        if (-not (Test-Path $path)) {
            $entry.note = "Path does not exist"
        } else {
            # Delete root files
            $files = Get-ChildItem -Path $path -File -Force -ErrorAction SilentlyContinue
            foreach ($file in $files) {
                if ($file.LastWriteTime -lt $cutoff) {
                    if ($dryRun) {
                        $entry.deletedFileCount++
                    } else {
                        try {
                            Remove-Item -LiteralPath $file.FullName -Force -ErrorAction Stop
                            $entry.deletedFileCount++
                        } catch { }
                    }
                }
            }

            # Delete subfolders by folder LastWriteTime only
            $dirs = Get-ChildItem -Path $path -Directory -Force -ErrorAction SilentlyContinue
            foreach ($dir in $dirs) {
                if ($dir.LastWriteTime -lt $cutoff) {
                    if ($dryRun) {
                        $entry.deletedFolderCount++
                    } else {
                        try {
                            [System.IO.Directory]::Delete($dir.FullName, $true)
                            $entry.deletedFolderCount++
                        } catch {
                            $entry.skippedFolderCount++
                        }
                    }
                } else {
                    $entry.skippedFolderCount++
                }
            }
        }

        $entry | ConvertTo-Json -Depth 3 | Set-Content -Path $outputPath -Encoding UTF8
    } -ArgumentList $jobSettings.path, $jobSettings.daystokeep, $jobSettings.dryRun, $jobSettings.outputPath

    $jobs += $job
    $index++
}

# Wait for all jobs
Write-Host "Waiting for cleanup jobs to complete..."
Wait-Job -Job $jobs
Write-Host "All jobs finished. Generating summary..."

# Merge results
$summary = [ordered]@{
    startedAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    endedAt   = $null
    dryRun    = $DryRun.IsPresent
    entries   = @()
}

foreach ($job in $jobs) {
    $jobDataPath = ($job.ChildJobs[0].Command | Out-String) -match 'job_(\d+).json' | Out-Null
    $jobId = $Matches[1]
    $jobOutputFile = "$tempDir\job_$jobId.json"

    if (Test-Path $jobOutputFile) {
        $data = Get-Content -Raw -Path $jobOutputFile | ConvertFrom-Json
        $summary.entries += $data
    }
}

$summary.endedAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

# Write final report
$finalReportPath = "cleanup_summary_$timestamp.json"
$summary | ConvertTo-Json -Depth 4 | Set-Content -Path $finalReportPath -Encoding UTF8
Write-Host "Summary saved to $finalReportPath"

# Optional cleanup
Remove-Job -Job $jobs -Force
Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
